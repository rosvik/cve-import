import { PrismaClient } from "@prisma/client";
import { DateFields, DbRow } from "../types/types";

export class DB {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  /**
   * Insert a batch of new rows into the database.
   *
   * @param rows An array of rows to be created
   */
  populate = async (rows: DbRow[]) => {
    try {
      await this.prisma.cVE.createMany({
        data: rows,
        skipDuplicates: true,
      });
    } catch (e) {
      console.error("Failed to populate database when inserting these ids: ");
      console.error(rows.map((d) => d.id));
      throw e;
    }
  };

  /**
   * Update a row in the database. If the row does not exist, create it.
   *
   * @param row The row to update or insert
   */
  upsertRow = async (row: DbRow) => {
    try {
      await this.prisma.cVE.upsert({
        where: {
          id: row.id,
        },
        update: {
          ...row,
        },
        create: row,
      });
    } catch (e) {
      console.log(row);
      console.error(e);
      console.error(JSON.stringify(e));
      throw e;
    }
  };

  /**
   * Get a row from the database by its ID.
   *
   * @param id The ID of the row to get
   */
  getRow = async (id: string) => {
    return await this.prisma.cVE.findUnique({
      where: {
        id,
      },
    });
  };

  /**
   * Get the N most recent rows from the database, based on the given field.
   *
   * @param N The number of rows to get
   */
  getLatest = async (field: DateFields, N: number) => {
    return await this.prisma.cVE.findMany({
      orderBy: {
        [field]: "desc",
      },
      where: {
        cveMetadata_datePublished: {
          not: null,
        },
      },
      take: N,
    });
  };

  disconnect = async () => {
    await this.prisma.$disconnect();
  };
}
