import { execute } from "./utils";

export class Git {
  dir: string;

  private debug: boolean;

  /**
   * Initialize a git object, which can run git commands in a specified directory
   *
   * @param dir The directory to run git commands in
   * @param debug Whether to log git commands to the console
   */
  constructor(dir: string, debug: boolean = false) {
    this.dir = dir;
    this.debug = debug;
  }

  /**
   * Get the current commit hash
   *
   * @returns The current commit hash
   */
  getCurrent(): Promise<string> {
    return this.exec("rev-parse HEAD");
  }

  /**
   * Get the commit hash of the previous commit.
   *
   * @returns The previous commit hash
   */
  getPrevious(): Promise<string> {
    return this.exec("rev-parse HEAD~1");
  }

  /**
   * Git fetch
   *
   * @returns The stdout of the git command
   */
  async fetch(): Promise<string> {
    return this.exec("fetch");
  }

  /**
   * Hard git reset to local main branch
   *
   * @returns The stdout of the git command
   */
  async reset(): Promise<string> {
    return this.exec("reset --hard main");
  }

  /**
   * Get the next commit hash, which is the next commit on origin/main that is
   * not in the current branch.
   *
   * @returns The next commit hash
   */
  async getNext(): Promise<string | false> {
    const next = await this.exec("rev-list HEAD..origin/main | tail -n 1");
    if (!next.length) return false;
    return next;
  }

  /**
   * Merge the next commit on origin/main into the current branch.
   *
   * @returns The stdout of the git command
   * @throws If there is no next commit hash
   */
  async goToNext(): Promise<string | false> {
    const next = await this.getNext();
    if (!next) return false;
    // Reset HEAD before merging, in case there are local changes
    await this.goTo("HEAD");
    return this.exec(`merge ${next}`);
  }

  /**
   * Go to the specified commit
   *
   * @param target The commit hash or reference to go to
   * @returns The stdout of the git command
   */
  async goTo(target: string): Promise<string> {
    return this.exec(`reset --hard ${target}`);
  }

  /**
   * Run a git command in the specified directory
   *
   * @param command The git command to run
   * @returns The stdout of the git command
   */
  private exec(command: string): Promise<string> {
    const cmd = `git -C ${this.dir} ${command}`;
    if (this.debug) console.debug(`RUNNING: ${cmd}`);
    return execute(cmd);
  }

  /**
   * Iterate through the git history, starting at the current commit and going
   * forward to the latest commit on origin/main.
   *
   * @returns An async iterator that yields the commit hash of each commit
   * @example
   * const git = new Git("../cvelistV5", true);
   * for await (const stdout of git) {
   *  console.log(stdout);
   * }
   */
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        const stdout = await this.goToNext();
        if (!stdout) {
          return { done: true, value: undefined };
        }
        return { done: false, value: stdout };
      },
    };
  }
}
