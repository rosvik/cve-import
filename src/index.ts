import { PrismaClient } from "@prisma/client";
import minimist from "minimist";
import { DbRow } from "./types/types";
import { getAllFileNames } from "./utils/getAllFileNames";
import { getCveFromFile } from "./utils/getCveFromFile";

const prisma = new PrismaClient();

const CVE_LIST_PATH = "./cvelistV5/cves";
const BATCH_SIZE = 100;

async function main() {
  const args = minimist(process.argv.slice(2));
  if (!(args.mode === "update" || args.mode === "populate")) {
    console.log("Specify `--mode populate` or `--mode update`");
    return;
  }

  const files: string[] = getAllFileNames(CVE_LIST_PATH);
  let rows: DbRow[] = [];

  if (args.mode === "populate") {
    /**
     * Populate empty database in batches. Ignore pre-existing rows.
     */
    for (let n = 0; n < files.length; n++) {
      const path = files[n];
      if (!path) continue;

      const cve = getCveFromFile(path);
      if (cve) rows.push(cve);

      if (n % BATCH_SIZE === 0) {
        const percentage = ((n / files.length) * 100).toFixed(1);
        const fromId = rows[0].id;
        const toId = rows[rows.length - 1].id;
        console.log(`${n} of ${files.length} (${percentage}%)`);
        console.log(`Uploading from ${fromId} to ${toId}`);

        await populateDb(rows);

        console.log("Done");
        rows = [];
      }
    }
  } else if (args.mode === "update") {
    /**
     * Update CVEs already in database, one by one
     */
    for (let n = files.length; n > 0; n--) {
      const path = files[n];
      if (!path) continue;

      const cve = getCveFromFile(path);

      if (cve) {
        await updateDbRow(cve);
      }

      const index = files.length - n;
      if (index % BATCH_SIZE === 0 || n === files.length - 1) {
        const percentage = ((index / files.length) * 100).toFixed(1);
        console.log(`${index} of ${files.length} (${percentage}%)`);
        console.log(`Updated ${cve?.id}`);
      }
    }
  }
}

const populateDb = async (rows: DbRow[]) => {
  try {
    await prisma.cVE.createMany({
      data: rows,
      skipDuplicates: true,
    });
  } catch (e) {
    console.log(rows.map((d) => d.id));
    console.error(e);
    console.error(JSON.stringify(e));
    throw e;
  }
};

const updateDbRow = async (row: DbRow) => {
  try {
    await prisma.cVE.upsert({
      where: {
        id: row.id,
      },
      update: {
        json: row.json,
      },
      create: row,
    });
  } catch (e) {
    console.log(row);
    console.error(e);
    console.error(JSON.stringify(e));
    throw e;
  }
};

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
